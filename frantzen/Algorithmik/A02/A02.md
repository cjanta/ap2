2.	Aufgabe
a) Die Krankenhaussoftware soll ein Modul zur Ausgabe eines Medikationsplans erhalten.
Hierzu soll die Methode ausgabe_medikationsplan() erstellt werden. Zur Vorbereitung werden Sie beauftragt, ein Sequenzdiagramm anzufertigen.
Folgende Klassen sind gegeben:
UI
-	patient : Patient
-	ausgabeMedikationsplan() : void
-	ausgabeMedikation(medikation : String) : void

Medikation
-	getEinnahme(medikament : Medikament, patient : Patient) : String

Verordnungen
-	getMedikamente(patient : Patient) : Medikament[]

MediDB
-	getStandardMedikation(medikament : Medikament) : String

Hinweis: Die Klassen Patient und Medikament sind nicht dargestellt.

Vorgangsbeschreibung zur Ausgabe eines Medikationsplanes:
Die Methode ausgabeMedikationsplan() der Klasse UI wird aufgerufen.
 Diese Methode kann durch Aufruf von getMedikamente(...) mit dem passenden Parameter eine Liste der Medikamente für den Patienten erhalten.
Für alle Elemente dieser Liste ruft die Methode ausgabeMedikationsplan() dann getEinnahme(...), auf, 
um für das jeweilige Medikament die Einnahmevorgaben des Arztes zu erhalten.
Wenn diese Methode einen leeren String zurückgibt, hat der Arzt keine spezielle Einnahme vorgegeben.
 In diesem Fall liefert die Methode getStandardMedikation(...) die für das Medikament hinterlegte Vorgabe zur Einnahme.
Wenn die Einnahmevorgaben (Standard oder vom Arzt vorgegeben) ermittelt sind, wird diese innerhalb der Methode ausgabeMedikationsplan() mit der Methode ausgabeMedikation(...) für das Medikament ausgegeben.
Ergänzen Sie das UML-Sequenzdiagramm nach diesen Vorgaben.

Diagramm siehe A02.drawio

# IHK Fragen zur Aufgabe:
b) Da aufgrund des Medikationsplans im Krankenhaus die Tabletten für Patienten zusammengestellt werden, ist die erstellte Methode sorgfältig zu testen.

ba) Der Projektleiter gibt den Einsatz von Überdeckungstests vor.
Nennen Sie eine geeignete Art der Testüberdeckung (Coverage) und begründen Sie Ihre Auswahl. 
[Arten der Tesüberdeckung:
- CO: Anweisungsüberdeckung (Alle Anweisungen, Zeilen werden getestet)
    - jede Anweisung muss einmal durchlaufen werden
    - kein unausgeführter Code im Programm

- C1: Zweicküberdeckung: (Selektionen werden getestet)
    - jeder Zweig wird getestet
    - Oft mehrere Durchläufe notwendig

- C2: Pfadüberdeckung: (Schleifen werden getestet)
    - Alle Ausführungspfade vom Anfang bis zum Ende einer Funktion werden durchlaufen
    - Dadurch werden vorherige Entscheidungen mitberücksichtigt
    - C2a: Alle möglichen Pfade
        - Problematisch bei Schleifen, da Werte variieren können
    - C2b: Boundary Interior: Schleifendurchlauf (kein Schleifendurchlauf oder ein Schleifendurchlauf)
    - C2c: Schleifendurchlauf = n
        - Schleifendurchlauf wird auf natürliche Zahl begrenzt.

- C3: Überprüfung hierarchicher (booescher) Bedingungen (Alle Konditions werden getestet)
    - Alle Kombinationen true/false
]
´´´´
Zweigüberdeckung ist geeignet, da sie sicherstellt, dass alle Entscheidungswege im Programm getestet werden und somit Fehler in der Logik aufgedeckt werden können – besonders wichtig bei sicherheitsrelevanten Anwendungen wie Medikationssystemen.
´´´´
bb) Überdeckungstests gehören zu den Whiteboxtests.
Beschreiben Sie, was einen Whiteboxtest auszeichnet.

Ein Whiteboxtest prüft die interne Logik und Struktur des Programmcodes, wobei der Tester Einblick in den Quellcode hat. 


bc) Ein Kollege fragt, wie das Programm reagieren soll, wenn die vom Arzt hinterlegte Medikation nur aus Leerzeichen besteht.
Beschreiben Sie eine geeignete Vorgehensweise. 

Bei Eingaben, die nur aus Leerzeichen bestehen, sollte das System diese als ungültig erkennen, eine entsprechende Fehlermeldung ausgeben und keine weitere Verarbeitung durchführen.


# Arten der Testüberdeckung (Coverage-Arten)
## 1. Anweisungsüberdeckung (Statement Coverage)

Beschreibung: Jede einzelne Programmanweisung wird mindestens einmal ausgeführt.

Ziel: Sicherstellen, dass jeder Codeabschnitt überhaupt getestet wird.

Beispiel: Jede Zeile Code wird einmal durchlaufen.

Typ: Struktureller Test (White-Box)

Einsatz: Einfachster und häufigster Überdeckungstest.

## 2. Zweigüberdeckung (Branch Coverage) / Entscheidungsüberdeckung

Beschreibung: Jeder mögliche Ausgang (true/false) einer Entscheidung (z. B. if-Bedingung) wird mindestens einmal getestet.

Ziel: Sicherstellen, dass alle möglichen Programmverzweigungen getestet werden.

Beispiel: Sowohl der if- als auch der else-Zweig werden ausgeführt.

Typ: White-Box-Test

Vorteil: Deckt mehr Logik ab als reine Anweisungsüberdeckung.

## 3. Bedingungsüberdeckung (Condition Coverage)

Beschreibung: Jede einzelne logische Bedingung innerhalb einer Entscheidung wird einmal als wahr und einmal als falsch getestet.

Ziel: Jede Teilaussage in zusammengesetzten Bedingungen wird überprüft.

Beispiel: In if (A && B) werden A und B getrennt getestet.

Typ: White-Box-Test

## 4. Mehrfache Bedingungsüberdeckung (Multiple Condition Coverage)

Beschreibung: Alle möglichen Kombinationen von Wahrheitswerten aller Teilbedingungen werden getestet.

Ziel: Maximale Überdeckung aller logischen Kombinationen.

Nachteil: Sehr hoher Testaufwand.

Typ: White-Box-Test

## 5. Pfadüberdeckung (Path Coverage)

Beschreibung: Alle möglichen Ausführungspfade im Programm werden getestet.

Ziel: Sicherstellen, dass jede mögliche Folge von Entscheidungen mindestens einmal ausgeführt wurde.

Typ: White-Box-Test

Nachteil: Bei komplexen Programmen exponentiell viele Pfade → praktisch oft nicht vollständig erreichbar.

## 6. Entscheidungs-/Bedingungsüberdeckung (Decision/Condition Coverage)

Beschreibung: Kombination aus Zweig- und Bedingungsüberdeckung.

Ziel: Sowohl jede Entscheidung als auch jede einzelne Bedingung wird getestet.

Typ: White-Box-Test

## 7. Modifizierte Bedingungs-/Entscheidungsüberdeckung (MC/DC – Modified Condition/Decision Coverage)

Beschreibung: Jede Bedingung innerhalb einer Entscheidung wird so getestet, dass gezeigt wird, dass sie allein den Entscheidungswert beeinflussen kann.

Verwendung: In sicherheitskritischer Software (z. B. Luftfahrt, Medizin).

Typ: White-Box-Test





# GPT Fragen und Antowrten zu Softwaretests:

Frage 1

Frage: „Nennen Sie drei Teststufen im Software-Test und erläutern Sie kurz, worauf jeweils besonders zu achten ist.“
Musterlösung:

Unit-Test (Modultest): Test einer einzelnen Komponente/Klasse. Wichtig ist, dass Abhängigkeiten (z. B. Datenbank, externe Services) durch Stubs oder Mocks ersetzt werden, damit der Test isoliert bleibt.

Integrationstest: Test mehrerer Komponenten, die zusammenarbeiten. Zu prüfen ist insbesondere, ob die Schnittstellen korrekt arbeiten, wie Daten weitergegeben werden und ob Fehler bei der Kooperation auftreten.

Systemtest: Gesamtes System in einer Umgebung, wie der späteren Nutzung. Neben Funktionalität sind auch nicht-funktionale Anforderungen wichtig (z. B. Performance, Sicherheit, Usability).

Frage 2

Frage: „Was versteht man unter Testüberdeckung (Coverage) und nennen Sie zwei konkrete Arten der Überdeckung.“
Musterlösung:
Testüberdeckung bedeutet, wieviel vom Code oder Logik durch Tests ausgeführt bzw. abgedeckt wurde — also welcher Anteil an möglichen Pfaden, Anweisungen oder Zweigen tatsächlich getestet wurde.
Zwei Arten:

Anweisungsüberdeckung (Statement Coverage): Wie viel Prozent der einzelnen Programm-Anweisungen wurden mindestens einmal durchlaufen.

Zweigüberdeckung (Branch Coverage): Wie viele Verzweigungen (z. B. „if“/„else“, „switch“) wurden in allen möglichen Richtungen getestet.

Frage 3

Frage: „Erläutern Sie den Unterschied zwischen einem Black-Box-Test und einem White-Box-Test.“
Musterlösung:

Black-Box-Test: Der Tester sieht das System von außen – Eingaben und Ausgaben sind bekannt, die interne Implementierung nicht. Fokus liegt auf Anforderungen, Nutzersicht, Funktionalität.

White-Box-Test: Der Tester kennt intern den Quellcode bzw. die Struktur. Tests zielen auf Kontrollfluss, Datenfluss, Pfade im Code ab. Die Implementierung wird direkt betrachtet.

Frage 4

Frage: „Sie sollen eine Funktion testen, die als Eingabe einen String entgegennimmt. Beschreiben Sie, wie Sie unter Verwendung von Äquivalenzklassen und Grenzwertanalysen geeignete Testfälle ableiten.“
Musterlösung:

Zuerst definieren Sie Äquivalenzklassen: z. B. gültiger String (nicht leer, erlaubte Zeichen), ungültiger String (leer, nur Leerzeichen, unzulässige Zeichen).

Dann Grenz- bzw. Sonderfälle: z. B. genau Länge = 0 (leer), Länge gleich maximal zulässiger Länge, nur Leerzeichen, Sonderzeichen am Anfang/Ende, extrem lange Eingabe.

Aus diesen Klassen und Grenzen ergeben sich Testfälle, z. B.: Eingabe = „“ (leer) → erwartetes Fehlverhalten; Eingabe = „ “ (nur Leerzeichen); Eingabe maximaler Länge; Eingabe mit Sonderzeichen.

Question 5

Frage: „Warum ist es sinnvoll, Fehler möglichst früh im Entwicklungsprozess durch Tests zu finden?“
Musterlösung:
Je früher ein Fehler erkannt wird (z. B. in der Anforderungs- oder Entwurfsphase), desto günstiger ist die Behebung — der Aufwand, schon eingebauten Code, Tests, Dokumentation oder gar produktive Systeme anzupassen, ist deutlich höher wenn der Fehler später gefunden wird. Zudem sinkt mit früher Fehlererkennung auch das Risiko für Folgeschäden, Verzögerungen oder Qualitätsverluste.
