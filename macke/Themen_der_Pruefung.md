 # Themenbereiche der Prüfung

Für Anwendungsentwickler:innen gibt es in der Abschlussprüfung vier Themenbereiche:

1. Planen und Umsetzen eines Softwareprojektes (das klassische „Abschlussprojekt“ mit Projektdokumentation) (auf dieser Seite nicht behandelt)
2. Planen eines Softwareproduktes (schriftliche Prüfung wie die ehemalige „GA1“)
3. Entwicklung und Umsetzung von Algorithmen (schriftliche Prüfung wie die ehemalige „GA1“)
4. Wirtschafts- und Sozialkunde (schriftliche Multiple-Choice-Prüfung wie bisher auch) (auf dieser Seite nicht behandelt)

# Planen und Umsetzen eines Softwareprojektes (das klassische „Abschlussprojekt“ mit Projektdokumentation)
Im Prüfungsbereich Planen und Umsetzen eines Softwareprojektes (Projekt) hat der Prüfling nachzuweisen, dass er in der Lage ist…

- kundenspezifische Anforderungen zu analysieren,
- eine Projektplanung durchzuführen,
- eine wirtschaftliche Betrachtung des Projektes vorzunehmen,
- eine Softwareanwendung zu erstellen oder anzupassen,
- die erstellte oder angepasste Softwareanwendung zu testen und ihre Einführung vorzubereiten und
- die Planung und Durchführung des Projektes anforderungsgerecht zu dokumentieren.

Daraus leiten sich fast wortwörtlich die Anforderungen für die Projektdokumentation bzw. deren Kapitel ab!

Im zweiten Teil der Prüfung (Projektpräsentation und Fachgespräch) hat der Prüfling nachzuweisen, dass er in der Lage ist…

- die Arbeitsergebnisse adressatengerecht zu präsentieren und
- seine Vorgehensweise bei der Durchführung der betrieblichen Projektarbeit zu begründen.
````
Die Projektpräsentation soll dabei höchstens 15 Minuten dauern.
````
# Planen eines Softwareproduktes (schriftliche Prüfung 1: 90min)
Im Prüfungsbereich Planen eines Softwareproduktes (PS) hat der Prüfling nachzuweisen, dass er in der Lage ist…

- Entwicklungsumgebungen und -bibliotheken auszuwählen und einzusetzen,
- Programmspezifikationen anwendungsgerecht festzulegen,
- Bedienoberflächen funktionsgerecht und ergonomisch zu konzipieren sowie
- Maßnahmen zur Qualitätskontrolle zu planen und durchzuführen.

# Entwicklung und Umsetzung von Algorithmen (schriftliche Prüfung 2: 90min)
Im Prüfungsbereich Entwicklung und Umsetzung von Algorithmen (EUA) hat der Prüfling nachzuweisen, dass er in der Lage ist…

- einen Programmcode zu interpretieren und eine Lösung in einer Programmiersprache zu erstellen,
- Algorithmen in eine Programmierlogik zu übertragen und grafisch darzustellen,
- Testszenarien auszuwählen und Testdaten zu generieren sowie
- Abfragen zur Gewinnung und Manipulation von Daten zu erstellen.

# Wirtschafts- und Sozialkunde (schriftliche Prüfung 3: 60min)
Im Prüfungsbereich Wirtschafts- und Sozialkunde (WiSo) hat der Prüfling nachzuweisen, dass er in der Lage ist…

allgemeine wirtschaftliche und gesellschaftliche Zusammenhänge der Berufs- und Arbeitswelt darzustellen und zu beurteilen.
# Prüfungsform

- Projekt: Praxisprojekt mit Projektdokumentation, Projektpräsentation und Fachgespräch
- PS: Schriftliche Abschlussprüfung, 90 Minuten, vier ungebundene Aufgaben, je Aufgabe kann es zwischen 20 und 30 Punkten geben, Gesamtzahl der möglichen Punkte: 100 Punkte
- EUA: Schriftliche Abschlussprüfung, 90 Minuten, vier ungebundene Aufgaben, je Aufgabe kann es zwischen 20 und 30 Punkten geben, Gesamtzahl der möglichen Punkte: 100 Punkte
- WiSo: Schriftliche Abschlussprüfung, 60 Minuten, ca. 30 gebundene Aufgaben (also maschinell auswertbar wie z.B. Multiple-Choice), je Aufgabe kann es verschiedene Punkte geben, Gesamtzahl der möglichen Punkte: 100 Punkte

Prüfungstermine sind Sommer und Winter
Gewichtung der Prüfungsteile

Einrichten eines IT-gestützten Arbeitsplatzes (Teil 1 der GAP): 20%
Planen und Umsetzen eines Softwareprojektes: 50%
die Projektdokumentation zählt hiervon 50%
Projektpräsentation und Fachgespräch zählen zusammen 50%
Planen eines Softwareproduktes: 10%
Entwicklung und Umsetzung von Algorithmen: 10%
Wirtschafts- und Sozialkunde: 10%
Relevante Lernfelder der Berufsschule

# Lernfelder Westerman
Da die „allgemeinen“ IT-Themen bereits in Teil 1 der gestreckten Abschlussprüfung abgefragt werden, dürfte sich die Liste der für die Abschlussprüfung relevanten Lernfelder aus der Berufsschule auf diese reduzieren:

LF 5: Software zur Verwaltung von Daten anpassen
LF 8: Daten systemübergreifend bereitstellen
LF 10a: Benutzerschnittstellen gestalten und entwickeln
LF 11a: Funktionalität in Anwendungen realisieren
LF 12a: Kundenspezifische Anwendungsentwicklung durchführen


# Konkrete Prüfungsthemen
Die Oberpunkte entsprechen den Teilen des Ausbildungsberufsbildes laut Ausbildungsrahmenplan (FIAusbV).

Die ersten Stichpunkte sind die laut Ausbildungsrahmenplan nicht in den ersten 18 Monaten der Ausbildung zu vermittelnden Fertigkeiten, Kenntnisse und Fähigkeiten zu den Oberpunkten.
Laut Ausbildungsrahmenplan sollen in Teil 2 der Abschlussprüfung Fertigkeiten, Kenntnisse und Fähigkeiten, die bereits Gegenstand von Teil 1 der Abschlussprüfung waren, eher nicht mehr abgefragt werden. Es ist aber nicht ganz auszuschließen, dass diese Themen drankommen. Totzdem fokussiere ich mich auf dieser Seite auf die „neuen“ Themen, da die „alten“ schon für Teil 1 der Prüfung bearbeitet wurden.



Letzte Aktualisierung: 10.01.2025


## Kundenbeziehungen ^
Kundenbeziehungen unter Beachtung rechtlicher Regelungen und betrieblicher Grundsätze gestalten
Kundengespräche strukturiert vorbereiten, durchführen und nachbereiten
konsequente Kundenausrichtung und systematische Gestaltung der Kundenbeziehungsprozesse („Relationship Marketing“)
Dokumentation und Verwaltung von Kundenbeziehungen („Customer Relationship Management“)
Gesetz gegen unlauteren Wettbewerb
AGB-Gesetz
Regelkonformität
Berücksichtigung der geltenden Compliance-Regelungen
Ethik

## Präsentieren ^
Gespräche situationsgerecht führen und Kunden und Kundinnen unter Berücksichtigung der Kundeninteressen beraten
Daten und Sachverhalte interpretieren, multimedial aufbereiten und situationsgerecht unter Nutzung digitaler Werkzeuge und unter Berücksichtigung der betrieblichen Vorgaben präsentieren
Präsentieren von Sachverhalten (auch softwarebasiert) unter Berücksichtigung von z.B. Gestaltungsgrundsätzen nach Kundenvorgaben, Dateiformaten
Anwenden von Kommunikations- und Argumentationstechniken
Präsentationstechniken
Grafische Darstellung bzw. Visualisierung (Diagrammarten, Bilderbearbeitung, Videos, multimediale Aufbereitung)
Tabellenkalkulation
Präsentationsprogramme
Programme zum Erstellen multimedialer Inhalte
Corporate Identity (CI)
Anwendung und Einarbeitung in marktübliche Präsentationssoftware
Vor- und Nachbereitung einer Präsentation
Elemente einer Präsentation beherrschen, z.B.:
Visualisierungsregeln
Farbwirkung
Rhetorikgrundlagen, z.B.:
Atem- und Sprechtechnik
Rede- und Vortragstechnik

## Trends ^
Technologische Entwicklungstrends von IT-Systemen feststellen sowie ihre wirtschaftlichen, sozialen und beruflichen Auswirkungen aufzeigen
Veränderungen von Einsatzfeldern für IT-Systeme aufgrund technischer, wirtschaftlicher und gesellschaftlicher Entwicklungen feststellen
Identifikation von Trends unter Berücksichtigung von Such- und Innovationsfeldern
Beschaffen von Informationen über Auswirkungen auf das eigene Unternehmen, die Branche und die Gesellschaft
Maßnahmen zur aktiven Information durch Newsfeeds oder Newsletter einleiten
Nutzen geeigneter Informationsquellen, z.B. Fachmessen, Fachforen im Internet, um neue Trends und Einsatzfelder wahrzunehmen
Anwendung von IT-Systemen auf neue Einsatzgebiete prüfen

## Datenbanken ^
Datentypen: Boolesche Werte, Ganzzahl, Gleitkommawerte, Währung, Datumswerte, Texte fester und variabler Länge, BLOB, Geokoordinaten
OpenData, API-Schnittstellen
Berücksichtigung vorhandener Datenbank- und Speicherkonzepte bei der Integration und Erweiterung von Bestandssystemen
Inbetriebnahme von Speicherlösungen und Integration von Datenbanksystemen
Beachten von Schnittstellen zu weiteren Systemen
Datenquellen: nicht nur relationelle und schemafreie Datenbanken wie MySQL, MsSQL und MongoDB, sondern auch z. B. Sensoren, CSV-Dateien
Begriffe kennen und erläutern
Redundanz
Kardinalitäten: 1:1, 1:n, m:n
Primär-/Fremdschlüssel und andere Schlüsseltypen: anonym, künstlich/natürlich
referentielle Integrität (Aktualisierungsweitergabe, Löschweitergabe)
Maßnahmen bei Löschoperationen (Constraints): CASCADE, DENY/RESTRICT, SET NULL, (NO ACTION)
Tiefergehende Datenbankobjekte: Index, Stored Procedure, Trigger, Sequence
Replikation
ACID-Prinzipien für Transaktionen kennen und erläutern (atomicity, consistency, isolation, durability)
Big Data
3V-Modell (Velocity, Volume, Variety), 4V-Modell: +Veracity
Streaming Analytics

## Datenbankmodelle und -modellierung ^
Datenbankmodelle unterscheiden, Daten organisieren und speichern sowie Abfragen erstellen
Basiswissen zu verschiedenen Datenbankarchitekturen
Relationale und nicht-relationale Datenbanken
verschiedene Datenbankmodelle, z.B. relationales Datenbankmodell, hierarchisches Modell, Entity-Relationship-Modell, semantische Datenmodelle, objektorientierte Datenmodelle, als theoretische Grundlage für eine Datenbank kennen und nach Einsatzszenario unterscheiden
NoSQL: dokumentenorientiert, spaltenorientiert, Key/Value-Store, objektorientiert, Graphendatenbank
CAP-Theorem (Consistency, Availability, Partition Tolerance)
Map/Reduce
BASE (Basically Available, Soft State, Eventual Consistency)
Phasen der Datenbankentwicklung kennen und anwenden
externe Phase (Informationsbeschaffung)
konzeptionelle Phase (Semantisches Modell)
logische Phase (Datenmodell)
physische Phase (Datenbankschema)
Grundlagen der Datenmodellierung anwenden, z.B. Entitäten, Relationsbeziehungen, Normalisierung, Identifikationsschlüssel
Definieren und Modellieren von Datenbankstrukturen, z.B. Entity-Relationship-Modell, Normalisierung
ER-Diagramm (Entity Relationship Model): Entitätstypen, Attribute, Beziehungen, Kardinalitäten
Crow’s Foot Notation

# Normalisierung ^
Normalformen erläutern („the key, the whole key, and nothing but the key“)
Normalisierung von Datenbanken bis zur 3. Normalform durchführen
Anomalien (Einfüge-, Änderungs-, Löschanomalie) erläutern
Modellierung von Beziehungen (1:1, 1:n, m:n)
mögliche Beispiele: Benutzer/Login (1:1), Benutzer/Bestellung (1:n), Benutzer/Benutzergruppe (m:n)

# SQL ^
Erstellen einfacher Abfragen von Datenquellen unter Verwendung einer Abfragesprache und komplexe Abfragen aus unterschiedlichen Datenquellen durchführen und Datenbestandsberichte erstellen
SQL als normierte Sprache für die weit verbreiteten relationalen Datenbanken zum Bearbeiten (Einfügen, Verändern, Löschen) und Abfragen von darauf basierenden Datenbeständen anwenden
Projektion vs. Selektion
Kreuzprodukt/kartesisches Produkt
DDL, DML, DQL, DCL, TCL
CRUD (Create, Read, Update, Delete): INSERT/SELECT/UPDATE/DELETE
SELECT-Aufbau rauf und runter: FROM, WHERE, JOIN, GROUP BY, HAVING, ORDER BY, (LIMIT)
Subqueries
LIKE-Syntax (Platzhalter)
Abfrage über mehrere Tabellen (JOIN)
verschiedene Joins erklären (INNER, OUTER LEFT/RIGHT/FULL, Natural, Self)
Ausdrücke und Bedingungen
Nutzung von Aggregatsfunktionen, z.B. COUNT, SUM, AVG
Tabellenstruktur (CREATE, ALTER, DROP, DESCRIBE, SHOW DATABASES, SHOW TABLES)
Manipulation (INSERT, UPDATE, DELETE)
Projektion (SELECT FROM)
Selektion (SELECT FROM… WHERE) und (SELECT… (SELECT…)), DISTINCT
Sortieren (ORDER BY ASC/DESC)
Gruppieren (GROUP BY, HAVING)
Index (CREATE INDEX)
Schnitt-, Vereinigungs- und Differenzmenge (INTERSECT, UNION (ALL), MINUS)
SQL Injection

# Qualitätssicherung ^
Ursachen von Qualitätsmängeln systematisch feststellen, beseitigen und dokumentieren
Verschiedene Prüfverfahren, z.B. Parität, Redundanz
Debugging, Ablaufverfolgung
Netzwerkanalyse, Bandbreite, Reaktionszeiten
Im Rahmen eines Verbesserungsprozesses die Zielerreichung kontrollieren, insbesondere einen Soll-Ist-Vergleich durchführen
Verbesserungsprozess, PDCA-Zyklus, KVP, Kennzahlen
Soll-Ist-Vergleich, Abweichungen erkennen und berechnen
Sicherheitsaspekte bei der Entwicklung von Softwareanwendungen berücksichtigen
Datenintegrität mithilfe von Werkzeugen sicherstellen
Constraints
Validierungen
Transaktionssicherheit
übergeordneter Problemlösungsprozess
Problemverständnis und -beschreibung (Define)
Problemanalyse und Ursachensuche (Measure)
Lösungssuche und -auswahl (Analyse)
Lösungsrealisierung und -bewertung (Improve)
Überprüfung der Wirksamkeit (Control)
verschiedene Methoden, insbesondere in den Stadien „Ursachensuche“ und „Analysieren“, kennen und anwenden, z.B.:
Ursachensuche: 6-W-Fragetechnik, Störungsmatrix, Histogramm, Verlaufsdiagramm, Korrelationsdiagramm
Analysieren: Brainstroming/-writing, Flussdiagramm, Ishikawa-Diagramm, Variablenvergleich, Messsystemanalyse, Komponententausch, Einsatz von Debuggern
Lösungsrealisierung bzw. Fehlerbehebung selbst vornehmen oder veranlassen und begleiten
Grundlagen/Methoden des Qualitätsmanagements und einer vorbeugenden Qualitätssicherung bei IT-Systemen kennen und anwenden
Qualitätsplanung (Ist-Zustand ermitteln und Ziel-Zustand festlegen)
Qualitätslenkung (Umsetzung der Planphase)
verschiedene Prüfverfahren kennen und bewerten, z. B. auf Parität, Redundanz
Grundkenntnisse in der Stochastik (Berechnung von Wahrscheinlichkeiten bei Qualitätsmängeln)
Qualitätssicherung (Auswertung relevanter Informationen)
Qualitätsgewinn (weitere Umsetzung und Mitteilen der gewonnenen Informationen an die betroffenen Stellen)
Qualitätsmanagement als selbstreferenziellen Prozess begreifen (die Verfahren zur Verbesserung lassen sich auch auf den Qualitätsmanagementprozess selbst anwenden)
Erstellen und Erweitern von Handbüchern für Benutzer und Systembetreuer
Berücksichtigung der Komplexität und Verständlichkeit bei der Nutzung von Herstellerdokumentationen zur Bereitstellung für den Anwender
Incident Management (Ticketsystem)
Standard Operation Procedures (SOP)
Service Level Agreement (SLA), Service level 1 -3
Lasten-/Pflichtenheft erstellen können

# Testen ^
Grundsätzliches Vorgehen beim Testen, z. B. print-Debugging, Test Driven Development (TDD), Unit-Test, E2E-Test
Klassifizierung von Testverfahren
Wer testet?
Mensch (manuell) vs. Maschine (automatisch)
Entwickler vs. Benutzer
Was wird getestet?
Komponente (Unit-Test/Funktionstest/Klassentest) vs. Integration vs. System (End-to-End)
Testpyramide
Wie wird getestet?
Bottom-Up vs. Top-Down
statisch (Kompilierzeit) vs. dynamisch (Laufzeit)
ohne Kenntnis des Codes (Blackbox) vs. mit Kenntnis des Codes (Whitebox)
explorativ
Schreibtischtest/Review
Wann wird getestet?
Vor vs. nach der Entwicklung
Abnahmetest
Warum wird getestet?
Regressionstest
Lasttest/Belastungstest/Performancetest
Smoketest
Methoden zur Ermittlung von Testfällen
Anweisungsüberdeckung vs. Zweig-/Pfadüberdeckung
Äquivalenzklassen
Grenzwertanalyse/Extremwertetest
Modultests erstellen und durchführen
Test-Doubles: Stubs vs. Mocks
Eigenschaften guter Unit-Tests: korrekt, isoliert, schnell, aussagekräftig, wartbar, einfach durchführbar
Testkonzepte erstellen und Tests durchführen sowie Testergebnisse bewerten und dokumentieren
Definition der Inhalte eines Tests, z.B. Testkonzepte, Testdaten, Testszenario
Beschreiben des Testumfangs, z.B. Grenzbelastung, Stabilität
Testdatengeneratoren
Daten und Sachverhalte aus Tests multimedial aufbereiten und situationsgerecht unter Nutzung digitaler Werkzeuge und unter Beachtung der betrieblichen Vorgaben präsentieren
Testprozess
Auswahl des Testverfahrens
Kriterien für Testergebnisse definieren
Testdaten generieren und auswählen
Testprotokoll und Auswertung
Auswerten von Testergebnissen, z.B. Soll-Ist-Vergleich
Testprotokolle
Kontrollverfahren
Software-Test, z.B. Testverfahren, Abnahmeprotokoll

# Versionsverwaltung ^
Werkzeuge zur Versionsverwaltung einsetzen
Eigenschaften eines Versionsverwaltungssystems beschreiben
SVN, CVS, TFS mit Source Safe, Git
VCS vs. DVCS
Nutzen und Anwenden einschlägiger Systeme, z.B. Git
Funktionen, z.B. Commit, Revert, Branch, Merge, Cherry-Pick, Pull/Push, Rebase
Übliche Workflows im Team, z.B. Pull/Merge Requests

# IT-Sicherheit ^
Datensicherheit (Authentifizierung, Autorisierung, Verschlüsselung)
Bedrohungsszenarien erkennen und Schadenspotenziale unter Berücksichtigung wirtschaftlicher und technischer Kriterien einschätzen
Für jede Anwendung, die verwendeten IT-Systeme und die verarbeiteten Informationen gilt: Betrachtung zu erwartender Schäden, die bei einer Beeinträchtigung von Vertraulichkeit, Integrität oder Verfügbarkeit entstehen könnten!
Imageschaden
Wirtschaftlicher Schaden
Datenverlust
Bedrohungsszenarien
Datendiebstahl
Digitale Erpressung (Ransomware)
Identitätsdiebstahl (Phishing)
Sicherheitskriterien
Richtschnur für Entwickler
Objektive Bewertung der Systeme (IT-Grundschutzmodellierung)
Anwender/Benutzer bei der Auswahl eines geeigneten IT-Sicherheitsprodukts unterstützen (Security by Design)
Kunden und Kundinnen im Hinblick auf Anforderungen an die IT-Sicherheit und an den Datenschutz beraten
Private Haushalte
Unternehmen (intern, extern)
Öffentliche Hand
Funktionale Anforderungen
Qualitätsanforderungen Anforderungen
Rahmenbedingungen
Technologisch
Organisatorisch
Rechtlich
Ethisch
Risikoanalyse
Wirksamkeit und Effizienz der umgesetzten Maßnahmen zur IT-Sicherheit und zum Datenschutz prüfen
Device Security Check
Identity & Access Management (IAM)
Schwachstellenanalyse (z.B. Ende-zu-Ende-Verschlüsselung)
Zutritt vs. Zugang vs. Zugriff
Zutrittskontrolle, z.B. Alarmanlage, Videoüberwachung, Besucherausweise
Zugangskontrolle, z.B. Bildschirmschoner mit Passwortschutz, Biometrische Verfahren, Magnet- oder Chipkarte
Zugriffskontrolle, z.B. Verschlüsselung von Datenträgern, Löschung von Datenträgern, User/Rollenkonzept
Log Management
Compliance Reports
unterschiedliche Gefahrenquellen, z.B. Stromausfall, Überhitzung, Virenbefall
geeignete Gegenmaßnahmen, z.B. USV-Anlagen, Klimageräte, Firewalls
Einteilung in die drei Schutzbedarfskategorien „normal“, „hoch“ und „sehr hoch“ (analog IT-Grundschutz des BSI)
IT-Sicherheitsregeln
verschiedene IT-Sicherheitszertifizierungen
Bundesamt für Sicherheit in der Informationstechnik (BSI) als Informationsplattform
Basis-Sicherheitscheck für schnellen Überblick über das vorhandene IT-Sicherheitsniveau, z.B. als Soll/Ist-Abgleich der noch fehlenden Maßnahmen oder Interviews über den Status quo eines bestehenden Informationsverbundes
ergänzende Sicherheitsanalyse mit Risikoanalyse (BSI-Standards 100-3)
Elementarrisiken, z. B. Feuer, Hochwasser
Sicherheitstest einzelner Rechner oder Netzwerke jeglicher Größe, z.B. durch Penetrationstest (auch Social-Engineering-Penetrationstest) gem. Klassifikationsschema des BSI
Durchführung in einem fünfstufigen Prozess
Vorbereitungsphase
Informationsbeschaffung
Bewertung der Informationen
Versuch des aktiven Eindringens
Auswertung der Ergebnisse
mögliche Software, Portscanner, Sniffer, Paketgeneratoren, Passwortcracker, Verbindungsinterceptoren, Vulnerability Scanner etc. (siehe auch Open Vulnerability Assessment System – OpenVAS – unterstützt durch das BSI)
Begriffe kennen/erläutern
Hacker (White Hat, Black Hat), Cracker, Script-Kiddies
Spam, Phishing, Sniffing, Spoofing, Man-in-the-Middle
SQL-Injection, XSS, CSRF, Session Hijacking, DoS, DDoS
https://xkcd.com/327/
Viren, Würmer, Trojaner, Hoax, Dialer (veraltet), Keylogger, Botnetze, Spyware, Adware, Ransomware, Scareware
Backdoor, Exploit, 0-Day-Exploit, Rootkit
Verbreitung von Viren/Würmer/Trojaner erläutern
Maßnahmen zur Angriffserkennung, z.B. Monitoring, Honeypot
OWASP Top 10: Injection, Misconfiguration, Broken Access Control, Monitoring Failures usw.
SQL Injection, Cross-Site-Scripting (XSS), Cross-Site-Request-Forgery (CSRF)
Gegenmaßnahmen auf Entwicklerseite (z.B. Validierung, Cross-Origin-Resource-Sharing (CORS))
Authentifizierungs- und Autorisierungsverfahren
Delegierte Authentifizierung
OAuth2
Single-Sign-On

# Datenschutz ^
Datenschutzgesetze – national und auf EU-Ebene, z.B. Datenschutzgrundverordnung (DSGVO), BDSG
Definition von personenbezogenen Daten
Grundsätze des Datenschutzes (Art. 5)
Rechtmäßigkeit/Gesetzmässigkeit (Erfordernis der gesetzlichen Grundlage)
Transparenz gegenüber den betroffenen Personen
Zweckbindung
Datenminimierung/Verhältnismässigkeit (Datensparsamkeit und Datenvermeidung)
Richtigkeit
Speicherbegrenzung
Integrität und Vertraulichkeit
Rechenschaftspflicht
Informationssicherheit
Betroffenenrechte
Recht auf Information
Recht auf Auskunft
Recht auf Berichtigung
Recht auf Löschung
Recht auf Einschränkung der Bearbeitung
Recht auf Widerspruch
Recht auf Datenübertragbarkeit
Persönlichkeitsrechte
Recht auf informationelle Selbstbestimmung
Recht am eigenen Bild
Recht am geschriebenen/gesprochenen Wort
Recht auf Schutz vor Imitation der Persönlichkeit
Recht auf Schutz der Intim-, Privat- und Geheimsphäre
Archivierung (rechtliche Vorgaben, Unterschied zu Backup, technologische Anforderungen)
Systeme, Fristen, Pflichten

# Netzwerktechnik ^
Netzwerkkonzepte für unterschiedliche Anwendungsgebiete unterscheiden
Datenaustausch von vernetzten Systemen realisieren
Verfügbarkeit und Ausfallwahrscheinlichkeiten analysieren und Lösungsvorschläge unterbreiten
Maßnahmen zur präventiven Wartung und zur Störungsvermeidung einleiten und durchführen
Störungsmeldungen aufnehmen und analysieren sowie Maßnahmen zur Störungsbeseitigung ergreifen
Dokumentationen zielgruppengerecht und barrierefrei anfertigen, bereitstellen und pflegen, insbesondere technische Dokumentationen, System- sowie Benutzerdokumentationen
Auswerten, Dokumentieren und Weiterleiten von Informationen und Störungsmeldungen
Ergreifen von Maßnahmen zur Problembeseitigung und ggf. fachlicher Austausch mit Systemlieferanten
ggf. Weiterleitung zur jeweiligen Fachabteilung oder Systemspezialisten
Adressierung
IPv4/IPv6, MAC, ARP
Routing, Switching
DNS, DHCP
TCP/UDP
HTTPS, TLS/SSL, IPsec
Hash, Signatur, Zertifikat, Certificate Authority
SMB, NFS
Ethernet, FibreChannel
Datenübertragungsraten
Verschlüsselung (pre-shared key)
Zugriffskontrolle im Netzwerk (RADIUS, Kerberos …)
LAN/WAN/MAN/GAN
Strukturierte Verkabelung
primäre/sekundäre/tertiäre Verkabelung
Kabeltypen
Simplex, Halb-/Vollduplex
10/100/1000Base-T
Twisted Pair, CAT5e/6/7 etc.
Fibre Channel, Lichtwellenleiter
DIN EN 50173-1
EM-Verträglichkeit
Switch, Bridge, Router
VLAN
Drahtlos: PAN/WLAN/Mesh, Bluetooth
Sicherheitskonzepte und -risiken: WEP, WPA
Netzwerktopologien
Netzwerkplan
VPN
Funktionsweise und Vorteile von VPN beschreiben
Protokolle/Ports, Verschlüsselungsverfahren
L2TP, PPTP, IPSec
VPN-Modelle
Tunneling
Echtzeitkommunikation sicherstellen können
Serverarten: Mailserver, Webserver, Groupware, Datenbanken, Proxy
ANR
Notfallkonzept (Disaster Recovery)
Sicherstellung des Betriebs
Elektrotechnisch (USV)
Hardwaretechnisch (Redundanzen), RAID
Softwaretechnisch (Back-ups…)
MTBF
SNMP, S.M.A.R.T. u.Ä.
Systemlastanalyse
Predictive Maintenance
Firewalls/Webfilter
Paketfilter, Stateful Inspection, Application Level
Portsecurity, Port-Forwarding
Datenabruf, z. B. HTTP, ODBC
Monitoring von Systemen
Festlegen der Monitoringdaten
Festlegen von Schwellwerten
Cyber-physische Systeme beschreiben und erweitern können
CPS-Software
Auswahl von geeigneten Sensoren/Aktoren
Nutzung von Bibliotheken
Abfragerhythmus planen
Kenntnis des Zugriffs auf Sensoren und Aktoren

# Speicherlösungen ^
Sicherheitsmechanismen, insbesondere Zugriffsmöglichkeiten und -rechte, festlegen und implementieren
Speicherlösungen, insbesondere Datenbanksysteme, integrieren
Zugangskontrollen (z.B. Gebäude, Serverraum, Schrank)
Implementierung und Inbetriebnahme des Zugriffs auf lokale und vernetzte Speicherlösungen sowie vernetzten Systemen, z.B. SAN, NAS, DAS
Eigenschaften/Unterscheidung/Vor-/Nachteile DAS, SAN und NAS
DAS, SAN und NAS: Grafik 1, Grafik 2
Berücksichtigung der Organisationsstrukturen im Unternehmen unter Beachtung von örtlichen Vorgaben
Usermanagement
Verschlüsselung (TPM, Bitlocker)
SaaS, IaaS, PaaS
Cloud Computing
Cloud vs. On Premises
Serverless (Function as a Service, Faas)
Data Lake
RAID
RAID 0, 1, 5, 6, 01, 10, JBOD erklären
Nested RAID levels

# Softwareentwicklung ^
Arten von Software unterscheiden (Individual-/Branchensoftware)
ERP, CRM, CAD, CMS, DMS, PPS, ECM, SCM (zwei Bedeutungen)
Programmspezifikationen festlegen, Datenmodelle und Strukturen aus fachlichen Anforderungen ableiten sowie Schnittstellen festlegen
Programmiersprachen auswählen und unterschiedliche Programmiersprachen anwenden
Teilaufgaben von IT-Systemen automatisieren
Skript- und Shellprogrammierung (z.B. Python)
herstellerabhängige Skriptbausteine und -sprachen anwenden, z.B.: Bash, PowerShell
wiederkehrende Systemabläufe automatisieren und überwachen
Optimieren und Automatisieren lokaler und netzwerkübergreifender Aufgaben
Bestehende Anwendungslösungen anpassen
Datenaustausch zwischen Systemen realisieren und unterschiedliche Datenquellen nutzen
Allgemeines Fehlerhandling in Programmen
Exceptions, Return/Exit Codes
Unterschied syntaktische/semantische Fehler
Systematisch Fehler erkennen, analysieren und beheben
Debugging, Break Point
Berücksichtigung anwendungsspezifischer Möglichkeiten, z.B. Makrosprache
Rechnerarchitektur: CPU, BUS, Speicher und deren Adressierung
Lizenzen unterscheiden
Open Source, proprietär
Informationspflichten zu Produkten, Namens- und Markenrecht, Urheber- und Nutzungsrecht, Persönlichkeitsrecht, unlauterer Wettbewerb
Apps
nativ vs. hybrid vs. cross-platform vs. responsive Web
Progressive Web Apps

# Algorithmen ^
Algorithmus: präzise (eigentlich von IT-Systemen unabhängige) Formulierung einer Verarbeitungsvorschrift
Algorithmen formulieren und Anwendungen in einer Programmiersprache erstellen
Abbildung der Kontrollstrukturen mittels Pseudocode oder Aktivitätsdiagramm als didaktisches Hilfsmittel
grundlegende Algorithmen kennen, eigene Algorithmen auch programmiersprachenfrei formulieren und zur Lösung von Problemen, z.B. in einem IT-System bzw. einer Softwareanwendung einsetzen
Entwickeln und Darstellen von Programmlogiken unabhängig von der Programmiersprache, z.B. mithilfe von Strukturdiagrammen und Verhaltensdiagrammen aus der UML
Kontrollstrukturen
allgemeine Programmstrukturen identifizieren/erläutern (Verzweigungen, Schleifen etc.)
Merkmale/Unterschiede von Kontrollstrukturen (Schleifen, Fallunterscheidungen)
grundlegende Kontrollstrukturen in allen Diagrammformen darstellen können: Pseudocode, UML
Zustandsübergänge eines Zustandsautomaten abbilden
Rekursion: Funktionsweise, Vor-/Nachteile
Basis-Algorithmen kennen
Lineare Suche, Binäre Suche
Bubble Sort, Selection Sort, Insertion Sort
Algorithmen implementieren/durchspielen
Mittelwert
doppelte Einträge in einem Array finden/löschen
Dateibäume rekursiv kopieren
(Zinses-)Zinsberechnung
Planen eines regelmäßigen Backups
Ablauf einer Benutzerauthentifizierung an einer Website
Abbuchen von einem Konto
Reguläre Ausdrücke zur Textanalyse erstellen

# Schnittstellen, APIs, Datenaustausch ^
Datenaustauschformate: CSV, XML, JSON
XML
vs. SGML, HTML, CSV, JSON, YAML etc.
Wohlgeformtheit, Validität
Parser, Serialisierer
SAX, DOM
DTD, Schema, RelaxNG, Schematron
XSLT, XSL-FO
JSON
Syntax, Vor-/Nachteile, Einsatzgebiete
REST
Adressierbarkeit, Zustandslosigkeit, einheitliche Schnittstelle (uniform interface), Ressource vs. Repräsentation
Hypermedia as the Engine of Application State (HATEOAS)
Code on Demand
Webservices/SOA
SOAP, WSDL

# Objektorientierung ^
Prinzipien der OOP
Begriffe der OOP erläutern: Attribut, Nachricht/Methodenaufruf, Persistenz, Schnittstelle/API/Interface, Kapselung, Polymorphie, Vererbung
Bestandteile von Klassen
Unterschied Klasse/Objekt
Unterschied Klasse/Interface
Erklärung Klassenbibliothek vs. Framework
Klassenbeziehungen: Assoziation, Aggregation, Komposition, Spezialisierung, Generalisierung
Generische Klassen (z.B. List)
Vorteile generischer Container (Templates in C++) gegenüber Arrays
Unterschied statische/nicht-statische Methoden und Attribute
Datenstrukturen
Queue, Baum, Stack, Heap, Array, Graph
funktionale Aspekte in modernen Sprachen: Lambda-Ausdrücke, Functional Interfaces, Map/Filter/Reduce, deklarativ vs. imperativ
Reactive Programming

# Programmiersprachen ^
Programmierparadigmen: unstrukturiert, strukturiert, prozedural, funktional, objektorientiert, logisch
Programmiersprachen vergleichen
Compiler vs. Interpreter
Programmierparadigma
Typisierung: statisch/dynamisch, stark/schwach
Syntax: z.B. C-ähnlich
General Purpose vs. Domain Specific
Abstraktionsniveau: 1GL, 2GL, 3GL, 4GL
imperativ vs. deklarativ
Portabilität (z.B. hardwarenah vs. virtuelle Maschine)
Skriptsprache
Performance/Speicherbedarf (Unterschiede bei der Programmierung/Ausführungsgeschwindigkeit in C, Java und JavaScript)
Einsatzzweck(e)
gängige Programmiersprachen kennen: PHP, Perl, Java, C, C++, C#, JavaScript, Delphi, Visual Basic, VBA, Ruby, Python, Cobol, F#, Lisp, Prolog, Assembler
synchrone vs. asynchrone Programmierung
Herausforderungen paralleler Programmierung
Einsatz von integrierten Entwicklungsumgebungen (IDE)
Framework vs. Bibliothek
Eigenschaften funktionaler Programmierung
Functions as „First Class Citizens“
Pure Functions
Higher Order Functions
Immutability
Fokus auf Rekursion (Tail Call Optimization)
Pattern Matching
No-/Low-Code-Plattformen

# UML ^
wichtige UML-Diagramme kennen und Einsatzgebiete erläutern
Klassendiagramm
Aktivitätsdiagramm
Anwendungsfalldiagramm (Use-Cases)
Sequenzdiagramm
Zustandsdiagramm/Zustandsautomat
Komponentendiagramm
Verteilungsdiagramm

# Softwarearchitektur ^
Anwendungslösungen unter Berücksichtigung der bestehenden Systemarchitektur entwerfen und realisieren
Berücksichtigung bestehender Systeme und Altsysteme
Anpassung bzw. Weiterentwicklung bestehender Software an eine neue Umgebung
Bottom-Up- und Top-Down-Verfahren bei der Modellierung erläutern
Funktion/Vorteile der Modularisierung von Programmen
Softwarearchitektur-Pattern
Monolith
3-Schichten-Modell/3-Tier
Schichtenmodell/Layers
Microservices
Model View Controller (MVC)
Model View Presenter (MVP)
Model-View-ViewModel (MVVM)
Pipes and Filters
Webservice/Service Oriented Architecture (SOA)
REST
verteilte Anwendungen: Webservices, Microservices, Client-Server, Cloud
Zustandslosigkeit, lose Kopplung
Container (Docker) und Kubernetes

# Softwareergonomie ^
Mock-up
Usability vs. User-Experience
Entwurf der Bildschirmausgabemasken (Softwareergonomie, Barrierefreiheit)
Benutzerschnittstellen ergonomisch gestalten und an Kundenanforderungen anpassen
übliche Gestaltungselemente für Benutzerschnittstellen (Controls): Button, Textfeld, Dropdown, Combobox usw.
Richtlinien bei der Gestaltung von Programmoberflächen
Aufgabenangemessenheit
Selbstbeschreibungsfähigkeit
Lernförderlichkeit
Steuerbarkeit
Erwartungskonformität
Individualisierbarkeit
Fehlertoleranz (siehe Grundsätze der Dialoggestaltung)
Barrierefreiheit bzw. Inklusives Design

# Software Engineering ^
Vorgehensmodelle und -methoden sowie Entwicklungsumgebungen und -bibliotheken auswählen und einsetzen
Analyse- und Designverfahren anwenden
Entwicklungsprozesse wie das Wasserfallmodell
Iterative Modelle, z.B. Spiralmodell, V-Modell (XT)
Agile Modelle: Scrum, Extreme Programming, Kanban
Top-Down-Entwurf vs. Bottom-Up-Entwurf
Entwicklungswerkzeuge: Editor, IDE, Programmgenerator, Linker, Compiler, Interpreter, Debugger, Testsoftware, Versionsverwaltung
Erstellen von Spezifikationen von Daten- und Programmstrukturen auf angemessenem Abstraktionsniveau
Nutzung von Prinzipien einer systematischen Programmierung nutzen (Strukturierung, Modularisierung, Mehrfachverwendung, Standardisierung)
Vorteile von Modularisierung
Anpassung aufgrund kundenspezifischer Anforderungen
Anforderungen aufnehmen und dokumentieren
funktionale/nicht-funktionale Anforderungen
Eigen- vs. Fremdfertigung
Künstliche Intelligenz (KI), Machine Learning (ML), autonome Systeme
Predictive Maintenance

# Design Patterns ^
Design Patterns kennen/erklären/implementieren
Singleton, Observer, Factory, Adapter, Iterator, Strategy, Decorator, Template Method, Registry, MVC

Softwarequalität ^
Beachten von Qualitätskriterien beim Programmieren mit branchentypischen Werkzeugen, Editoren, Entwicklungsumgebungen
Anforderungen: Änderbarkeit/Erweiterbarkeit, Benutzbarkeit, Effizienz, Funktionalität, Übertragbarkeit, Zuverlässigkeit, Wartbarkeit, Normen anwenden
Definition Software-Qualität
Software-Qualitätsmerkmale nach ISO 9126 nennen und erläutern
Funktionalität: Angemessenheit, Interoperabilität, Ordnungsmäßigkeit, Richtigkeit, Sicherheit
Änderbarkeit: Analysierbarkeit, Modifizierbarkeit, Testbarkeit, Stabilität
Übertragbarkeit: Anpassbarkeit, Austauschbarkeit, Installierbarkeit, Koexistenz
Effizienz: Verbrauchsverhalten, Zeitverhalten
Zuverlässigkeit: Fehlertoleranz, Reife, Wiederherstellbarkeit
Benutzbarkeit: Attraktivität, Bedienbarkeit, Erlernbarkeit, Verständlichkeit
Software-Qualitätsmerkmale nach ISO 25010 nennen und erläutern
Functional Suitability: Functional Completeness, Functional Correctness, Functional Appropriateness
Performance Efficiency: Time Behaviour, Resource Utilization, Capacity
Compatibility: Co-existence, Interoperability
Usability: Appropriateness Recognizability, Learability, Operability, User Error Protection, User Interface Aesthetics, Accessibility
Reliability: Maturity, Availability, Fault Tolerance, Recoverability
Security: Confidentiality, Integrity, Non-repudiation, Authenticity, Accountability
Maintainability: Modularity, Reusability, Analysability, Modifiability, Testability
Portability: Adaptability, Installability, Replaceability
Maßnahmen zur Qualitätssicherung
Audits, Code Reviews, Testmethoden, Entwicklungsprozess, Dokumentation, statische Codeanalyse, Pair Programming, Bugtracking
Continuous Integration/Delivery/Deployment
Dokumentation
Benutzerdokumentation (Handbuch)
Schnittstellendokumentation
Programmdokumentation (Source Code)
Netzwerkdokumentation
Testprotokolle
Checklisten

# Webentwicklung ^
dynamische Websites (CGI, ASP, JSP, PHP)
Applet und Servlet unterscheiden (veraltet)
Web 2.0
Social Networks, Wikis, Blogs, Twitter, Forum, Podcast
Web 3.0
RIA und AJAX
Vor-/Nachteile
Funktionsweise
Anforderungen durch Mobilgeräte
Offline-Fähigkeit, Deployment auf mehrere Plattformen, verschiedene Programmiersprachen, native Apps vs. HTML5/JavaScript, geringe Bandbreiten, kleine Auflösungen
Angriffsmöglichkeiten gegen Anwendungen abgrenzen
SQL-Injection, XSS, CSRF, Session Hijacking, DoS, DDoS
HTTP
Methoden kennen und einordnen: safe/sicher, idempotent
Status-Codes kennen (z.B. 200, 404)